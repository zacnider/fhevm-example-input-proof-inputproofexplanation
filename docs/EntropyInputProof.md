# EntropyInputProof

Input proofs with EntropyOracle integration

## Overview

@title EntropyInputProof
@notice Input proofs with EntropyOracle integration
@dev Educational example explaining input proofs with EntropyOracle
This example demonstrates:
- What input proofs are
- Why they're required for external encrypted inputs
- How to use them correctly with EntropyOracle
- Security implications
- Entropy-enhanced input validation
Input Proofs:
- Required when receiving encrypted data from users (externalEuint64)
- Prove that the encrypted value is valid and properly encrypted
- Prevent malicious or invalid encrypted inputs
- Generated by FHEVM SDK when creating encrypted inputs

@notice Constructor - sets EntropyOracle address
@param _entropyOracle Address of EntropyOracle contract

@notice Store encrypted value with input proof
@param encryptedInput Encrypted value from user (externalEuint64)
@param inputProof Input proof validating the encrypted value
@dev
Input Proof Requirements:
1. Must be provided for all externalEuint64 inputs
2. Validates that the encrypted value is properly encrypted
3. Prevents invalid or malicious encrypted inputs
4. Generated automatically by FHEVM SDK
Why Input Proofs?
- Security: Prevents invalid encrypted values
- Validation: Ensures encryption is correct
- Trust: Verifies the value came from FHEVM SDK

@notice Request entropy for enhanced input validation
@param tag Unique tag for this request
@return requestId Request ID from EntropyOracle
@dev Requires 0.00001 ETH fee

@notice Store value with entropy enhancement and input proof
@param encryptedInput Encrypted value from user
@param inputProof Input proof validating the encrypted value
@param requestId Request ID from requestEntropy()

@notice Get stored encrypted value
@return Encrypted value

@notice Check if initialized

@notice Get EntropyOracle address



## Contract Code

```solidity
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.27;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";
import "./IEntropyOracle.sol";

/**
 * @title EntropyInputProof
 * @notice Input proofs with EntropyOracle integration
 * @dev Educational example explaining input proofs with EntropyOracle
 * 
 * This example demonstrates:
 * - What input proofs are
 * - Why they're required for external encrypted inputs
 * - How to use them correctly with EntropyOracle
 * - Security implications
 * - Entropy-enhanced input validation
 * 
 * Input Proofs:
 * - Required when receiving encrypted data from users (externalEuint64)
 * - Prove that the encrypted value is valid and properly encrypted
 * - Prevent malicious or invalid encrypted inputs
 * - Generated by FHEVM SDK when creating encrypted inputs
 */
contract EntropyInputProof is ZamaEthereumConfig {
    // Entropy Oracle interface
    IEntropyOracle public entropyOracle;
    
    euint64 private storedValue;
    bool private initialized;
    
    // Track entropy requests
    mapping(uint256 => bool) public entropyRequests;
    
    event ValueStored(address indexed user);
    event EntropyRequested(uint256 indexed requestId, address indexed caller);
    event ValueStoredWithEntropy(uint256 indexed requestId, address indexed user);
    
    /**
     * @notice Constructor - sets EntropyOracle address
     * @param _entropyOracle Address of EntropyOracle contract
     */
    constructor(address _entropyOracle) {
        require(_entropyOracle != address(0), "Invalid oracle address");
        entropyOracle = IEntropyOracle(_entropyOracle);
    }
    
    /**
     * @notice Store encrypted value with input proof
     * @param encryptedInput Encrypted value from user (externalEuint64)
     * @param inputProof Input proof validating the encrypted value
     * @dev 
     * Input Proof Requirements:
     * 1. Must be provided for all externalEuint64 inputs
     * 2. Validates that the encrypted value is properly encrypted
     * 3. Prevents invalid or malicious encrypted inputs
     * 4. Generated automatically by FHEVM SDK
     * 
     * Why Input Proofs?
     * - Security: Prevents invalid encrypted values
     * - Validation: Ensures encryption is correct
     * - Trust: Verifies the value came from FHEVM SDK
     */
    function storeWithProof(
        externalEuint64 encryptedInput,
        bytes calldata inputProof
    ) external {
        require(!initialized, "Already initialized");
        
        // FHE.fromExternal requires inputProof to validate the encrypted input
        // This is a security measure to ensure the encrypted value is valid
        euint64 internalValue = FHE.fromExternal(encryptedInput, inputProof);
        
        // After validation, allow contract to use
        FHE.allowThis(internalValue);
        
        storedValue = internalValue;
        initialized = true;
        
        emit ValueStored(msg.sender);
    }
    
    /**
     * @notice Request entropy for enhanced input validation
     * @param tag Unique tag for this request
     * @return requestId Request ID from EntropyOracle
     * @dev Requires 0.00001 ETH fee
     */
    function requestEntropy(bytes32 tag) external payable returns (uint256 requestId) {
        require(msg.value >= entropyOracle.getFee(), "Insufficient fee");
        
        requestId = entropyOracle.requestEntropy{value: msg.value}(tag);
        entropyRequests[requestId] = true;
        
        emit EntropyRequested(requestId, msg.sender);
        return requestId;
    }
    
    /**
     * @notice Store value with entropy enhancement and input proof
     * @param encryptedInput Encrypted value from user
     * @param inputProof Input proof validating the encrypted value
     * @param requestId Request ID from requestEntropy()
     */
    function storeWithProofAndEntropy(
        externalEuint64 encryptedInput,
        bytes calldata inputProof,
        uint256 requestId
    ) external {
        require(!initialized, "Already initialized");
        require(entropyRequests[requestId], "Invalid request ID");
        require(entropyOracle.isRequestFulfilled(requestId), "Entropy not ready");
        
        // Validate input with proof
        euint64 internalValue = FHE.fromExternal(encryptedInput, inputProof);
        FHE.allowThis(internalValue);
        
        // Get entropy
        euint64 entropy = entropyOracle.getEncryptedEntropy(requestId);
        FHE.allowThis(entropy);
        
        // Combine value with entropy
        euint64 enhancedValue = FHE.xor(internalValue, entropy);
        FHE.allowThis(enhancedValue);
        
        storedValue = enhancedValue;
        initialized = true;
        
        entropyRequests[requestId] = false;
        emit ValueStoredWithEntropy(requestId, msg.sender);
    }
    
    /**
     * @notice Get stored encrypted value
     * @return Encrypted value
     */
    function getStoredValue() external view returns (euint64) {
        require(initialized, "Not initialized");
        return storedValue;
    }
    
    /**
     * @notice Check if initialized
     */
    function isInitialized() external view returns (bool) {
        return initialized;
    }
    
    /**
     * @notice Get EntropyOracle address
     */
    function getEntropyOracle() external view returns (address) {
        return address(entropyOracle);
    }
}

```

## Tests

See [test file](../examples/input-proof-inputproofexplanation/test/EntropyInputProof.test.ts) for comprehensive test coverage.

```bash
npm test
```


## Category

**input**



## Related Examples

- [All input examples](../examples/input/)
